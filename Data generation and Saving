import os
import jax
import jax.numpy as jnp
import numpy as np
from tqdm import tqdm

# GitHub parameters
username = "gabriellarmaraud"
repo = "ML-Project"
branch = "main"

# Define repository URL
repo_url = f"https://github.com/{username}/{repo}.git"

# Simulation Parameters
N_ITERATIONS = 10_000
PLOT_EVERY_N_STEPS = 100
SKIP_FIRST_N_ITERATIONS = 5000

# Parameters based on the newtonian_fluids dictionary
NUM_DYNAMIC_VISCOSITIES = 100  # Number of dynamic viscosities to test
NUM_VELOCITIES = 20          # Number of velocities to test

# Extract min and max viscosities dynamically from the dictionary
min_viscosity = min(f["dynamic_viscosity"] for f in newtonian_fluids.values())
max_viscosity = max(f["dynamic_viscosity"] for f in newtonian_fluids.values())

# Determine the format for displaying viscosities
significant_digits = max(len(f"{min_viscosity:.1e}".split("e")[0]), len(f"{max_viscosity:.1e}".split("e")[0]))
viscosity_format = f".{significant_digits - 1}e"  # Dynamic scientific notation format

# Generate viscosities with dynamic precision
viscosities = np.linspace(min_viscosity, max_viscosity, NUM_DYNAMIC_VISCOSITIES)

# Extract global speed limit (minimum across all fluids for incompressibility)
min_velocity = 0.001  # Physically realistic minimum velocity
global_speed_limit = min(f["incompressible_speed_limit"] for f in newtonian_fluids.values())
velocities = np.linspace(min_velocity, global_speed_limit, NUM_VELOCITIES)

# Cylinder diameter for Reynolds calculation
CYLINDER_DIAMETER = 50

# Base path for GitHub repository (local path after cloning)
BASE_PATH = '/content/ML-Project/simulations'

# Mesh and parameters
N_POINTS_X = 300
N_POINTS_Y = 50
CYLINDER_CENTER_INDEX_X = N_POINTS_X // 5
CYLINDER_CENTER_INDEX_Y = N_POINTS_Y // 2
CYLINDER_RADIUS_INDICES = N_POINTS_Y // 9

N_DISCRETE_VELOCITIES = 9

# Lattice parameters
LATTICE_VELOCITIES = jnp.array([[0, 1, 0, -1, 0, 1, -1, -1, 1],
                                 [0, 0, 1, 0, -1, 1, 1, -1, -1]])
LATTICE_WEIGHTS = jnp.array([4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36])

# Interpolation function for density
def interpolate_density(mu, fluids_dict):
    mu_values = [f["dynamic_viscosity"] for f in fluids_dict.values()]
    rho_values = [f["density"] for f in fluids_dict.values()]
    return np.interp(mu, mu_values, rho_values)

# Functions for LBM calculations
def get_density(discrete_velocities):
    return jnp.sum(discrete_velocities, axis=-1)

def get_macroscopic_velocities(discrete_velocities, density):
    return jnp.einsum("NMQ,dQ->NMd", discrete_velocities, LATTICE_VELOCITIES) / density[..., jnp.newaxis]

def get_equilibrium_discrete_velocities(macroscopic_velocities, density):
    projected_discrete_velocities = jnp.einsum("dQ,NMd->NMQ", LATTICE_VELOCITIES, macroscopic_velocities)
    macroscopic_velocity_magnitude = jnp.linalg.norm(macroscopic_velocities, axis=-1, ord=2)
    return (
        density[..., jnp.newaxis]
        * LATTICE_WEIGHTS[jnp.newaxis, jnp.newaxis, :]
        * (
            1
            + 3 * projected_discrete_velocities
            + 9/2 * projected_discrete_velocities**2
            - 3/2 * macroscopic_velocity_magnitude[..., jnp.newaxis]**2
        )
    )

# Main simulation function
def main():
    jax.config.update("jax_enable_x64", True)

    # Clone the GitHub repository
    if not os.path.exists("/content/ML-Project"):
        os.system(f"git clone {repo_url}")

    for dynamic_viscosity in viscosities:
        # Format the viscosity dynamically
        formatted_viscosity = format(dynamic_viscosity, viscosity_format)

        # Interpolate density for the current viscosity
        density = interpolate_density(dynamic_viscosity, newtonian_fluids)

        # Create the directory for the current viscosity
        viscosity_folder = f"mu_{formatted_viscosity}"
        base_folder = os.path.join(BASE_PATH, f"d_{CYLINDER_DIAMETER}", viscosity_folder)
        os.makedirs(base_folder, exist_ok=True)

        for velocity in velocities:
            reynolds_number = (density * velocity * CYLINDER_DIAMETER) / dynamic_viscosity

            if reynolds_number < 1:
                print(f"Skipping simulation: Reynolds number {reynolds_number:.2f} < 1 (velocity = {velocity:.4f} m/s)")
                continue

            print(f"Dynamic Viscosity: {formatted_viscosity} Pa·s | Density: {density:.2f} kg/m³ | Velocity: {velocity:.4f} m/s | Reynolds: {reynolds_number:.2f}")

            kinematic_viscosity = dynamic_viscosity / density
            relaxation_omega = 1.0 / (3.0 * kinematic_viscosity + 0.5)

            # Initialize discrete velocities for the simulation
            discrete_velocities = jnp.ones((N_POINTS_X, N_POINTS_Y, N_DISCRETE_VELOCITIES)) * LATTICE_WEIGHTS

            # Array to store velocity fields across time
            velocity_fields = []

            for iteration_index in tqdm(range(N_ITERATIONS)):
                # Compute density and velocity fields
                density_field = get_density(discrete_velocities)
                velocity_field = get_macroscopic_velocities(discrete_velocities, density_field)

                # Save data for the current iteration if needed
                if iteration_index % PLOT_EVERY_N_STEPS == 0 and iteration_index >= SKIP_FIRST_N_ITERATIONS:
                    velocity_magnitude = jnp.linalg.norm(velocity_field, axis=-1, ord=2)
                    velocity_fields.append(
                        jnp.stack([velocity_field[..., 0], velocity_field[..., 1], velocity_magnitude], axis=-1)
                    )

                # Compute equilibrium distribution
                equilibrium_discrete_velocities = get_equilibrium_discrete_velocities(velocity_field, density_field)

                # Collision step
                discrete_velocities = discrete_velocities - relaxation_omega * (discrete_velocities - equilibrium_discrete_velocities)

                # Streaming step
                for i in range(N_DISCRETE_VELOCITIES):
                    discrete_velocities = discrete_velocities.at[:, :, i].set(
                        jnp.roll(
                            jnp.roll(
                                discrete_velocities[:, :, i],
                                LATTICE_VELOCITIES[0, i], axis=0,
                            ),
                            LATTICE_VELOCITIES[1, i], axis=1,
                        )
                    )

            # Save all velocity data to a single file
            velocity_data_array = jnp.array(velocity_fields)
            filename = f"r_{int(density)}_Re_{int(reynolds_number)}_v_{velocity:.3f}.npz"
            np.savez(
                os.path.join(base_folder, filename),
                velocity_data=velocity_data_array,
                description="Data format: (time, x, y, [u_x, u_y, |u|])",
            )

            print(f"Simulation complete for dynamic_viscosity = {formatted_viscosity} Pa·s | Velocity = {velocity:.4f}")

    # Git commands to push the files to GitHub
    print("Pushing data to GitHub...")
    os.system(f"cd /content/ML-Project && git add .")
    os.system('git config --global user.email "gabriel.larmaraud@edu.devinci.fr"')
    os.system('git config --global user.name "Gabriellarmaraud"')
    os.system(f'cd /content/ML-Project && git commit -m "Add simulation data for branch {branch}"')
    os.system(f'cd /content/ML-Project && git push origin {branch}')
    print("All data pushed to GitHub.")

if __name__ == "__main__":
    main()
